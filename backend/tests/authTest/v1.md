C:\Users\Hans Candor\Documents\4th Year\capstone-project>npm test

> test
> npm run test -w backend


> backend@1.0.0 test
> node --experimental-vm-modules ../node_modules/jest/bin/jest.js

  console.error
    [authenticate] No authorization header

      11 |   
      12 |   if (!authHeader) {
    > 13 |     console.error('[authenticate] No authorization header');
         |             ^
      14 |     return res.status(401).json({ message: 'Authorization header required' });
      15 |   }
      16 |

      at authenticate (middleware/authenticate.js:13:13)
      at Object.<anonymous> (tests/middleware/authenticate.test.js:41:7)

  console.error
    [authenticate] Invalid token format: Basic sometoken

      16 |
      17 |   if (!authHeader.startsWith('Bearer ')) {
    > 18 |     console.error('[authenticate] Invalid token format:', authHeader.substring(0, 20));
         |             ^
      19 |     return res.status(401).json({ message: 'Invalid token format (Bearer required)' });
      20 |   }
      21 |

      at authenticate (middleware/authenticate.js:18:13)
      at Object.<anonymous> (tests/middleware/authenticate.test.js:53:7)

  console.error                                                                                                                                     
    [authenticate] Invalid token: jwt must be provided                                                                                              

      40 |       return res.status(401).json({ message: 'Token expired' });
      41 |     }
    > 42 |     console.error('[authenticate] Invalid token:', err.message);
         |             ^
      43 |     return res.status(403).json({ message: 'Invalid token' });
      44 |   }
      45 | }

      at authenticate (middleware/authenticate.js:42:13)
      at Object.<anonymous> (tests/middleware/authenticate.test.js:65:7)

  console.log
    [authenticate] Token verified for user: user-123 role: Admin

      at authenticate (middleware/authenticate.js:27:13)

  console.error                                                                                                                                     
    [authenticate] Token expired for request                                                                                                        

      37 |   } catch (err) {
      38 |     if (err.name === 'TokenExpiredError') {
    > 39 |       console.error('[authenticate] Token expired for request');
         |               ^
      40 |       return res.status(401).json({ message: 'Token expired' });
      41 |     }
      42 |     console.error('[authenticate] Invalid token:', err.message);

      at authenticate (middleware/authenticate.js:39:15)
      at Object.<anonymous> (tests/middleware/authenticate.test.js:104:7)

  console.error
    [authenticate] Invalid token: invalid signature

      40 |       return res.status(401).json({ message: 'Token expired' });
      41 |     }
    > 42 |     console.error('[authenticate] Invalid token:', err.message);
         |             ^
      43 |     return res.status(403).json({ message: 'Invalid token' });
      44 |   }
      45 | }

      at authenticate (middleware/authenticate.js:42:13)
      at Object.<anonymous> (tests/middleware/authenticate.test.js:122:7)

  console.error                                                                                                                                     
    [authenticate] Invalid token: jwt malformed

      40 |       return res.status(401).json({ message: 'Token expired' });
      41 |     }
    > 42 |     console.error('[authenticate] Invalid token:', err.message);
         |             ^
      43 |     return res.status(403).json({ message: 'Invalid token' });
      44 |   }
      45 | }

      at authenticate (middleware/authenticate.js:42:13)
      at Object.<anonymous> (tests/middleware/authenticate.test.js:134:7)

  console.error                                                                                                                                     
    [authenticate] Invalid token: invalid signature                                                                                                 

      40 |       return res.status(401).json({ message: 'Token expired' });
      41 |     }
    > 42 |     console.error('[authenticate] Invalid token:', err.message);
         |             ^
      43 |     return res.status(403).json({ message: 'Invalid token' });
      44 |   }
      45 | }

      at authenticate (middleware/authenticate.js:42:13)
      at Object.<anonymous> (tests/middleware/authenticate.test.js:162:7)

  console.log                                                                                                                                       
    [authenticate] Token verified for user: user-456 role: Business Owner                                                                           

      at authenticate (middleware/authenticate.js:27:13)

  console.log                                                                                                                                       
    [authenticate] Token verified for user: user-789 role: Tourist                                                                                  

      at authenticate (middleware/authenticate.js:27:13)

  console.log
    [authenticate] Token verified for user: user-minimal role: undefined

      at authenticate (middleware/authenticate.js:27:13)

  console.error                                                                                                                                     
    [authenticate] Invalid token format: bearer eyJhbGciOiJIU                                                                                       

      16 |
      17 |   if (!authHeader.startsWith('Bearer ')) {
    > 18 |     console.error('[authenticate] Invalid token format:', authHeader.substring(0, 20));
         |             ^
      19 |     return res.status(401).json({ message: 'Invalid token format (Bearer required)' });
      20 |   }
      21 |

      at authenticate (middleware/authenticate.js:18:13)
      at Object.<anonymous> (tests/middleware/authenticate.test.js:235:7)

  console.error                                                                                                                                     
    [authenticate] Invalid token: jwt must be provided                                                                                              

      40 |       return res.status(401).json({ message: 'Token expired' });
      41 |     }
    > 42 |     console.error('[authenticate] Invalid token:', err.message);
         |             ^
      43 |     return res.status(403).json({ message: 'Invalid token' });
      44 |   }
      45 | }

      at authenticate (middleware/authenticate.js:42:13)
      at Object.<anonymous> (tests/middleware/authenticate.test.js:253:7)

(node:12792) ExperimentalWarning: VM Modules is an experimental feature and might change at any time
(Use `node --trace-warnings ...` to show where the warning was created)
 PASS  tests/middleware/authenticate.test.js
  authenticate middleware                                                                                                                           
    Authorization Header Validation                                                                                                                 
      √ should return 401 if no authorization header is provided (28 ms)                                                                            
      √ should return 401 if authorization header does not start with Bearer (6 ms)                                                                 
      √ should return 401 if authorization header is just "Bearer" without token (6 ms)                                                             
    Token Validation                                                                                                                                
      √ should call next() and set req.user for valid token (12 ms)                                                                                 
      √ should return 401 for expired token (7 ms)                                                                                                  
      √ should return 403 for token signed with wrong secret (6 ms)                                                                                 
      √ should return 403 for malformed token (4 ms)                                                                                                
      √ should return 403 for tampered token payload (6 ms)                                                                                         
    User Object Population                                                                                                                          
      √ should correctly map role from token to user_role_id and role (5 ms)                                                                        
      √ should handle tokens with additional claims (7 ms)                                                                                          
    Edge Cases                                                                                                                                      
      √ should handle token with minimal payload (5 ms)                                                                                             
      √ should handle lowercase bearer prefix (5 ms)                                                                                                
      √ should handle authorization header with extra spaces (7 ms)                                                                                 
                                                                                                                                                    
  console.warn
    [RateLimit] Blocked request from 10.0.0.2 (4 attempts)

      75 |
      76 |     if (entry.count > maxAttempts) {
    > 77 |       console.warn(`[RateLimit] Blocked request from ${key} (${entry.count} attempts)`);
         |               ^
      78 |       
      79 |       return res.status(429).json({
      80 |         message,

      at middleware/rateLimit.js:77:15
      at Object.<anonymous> (tests/middleware/rateLimit.test.js:75:7)

  console.warn
    [RateLimit] Blocked request from 10.0.0.5:user@test.com (3 attempts)

      75 |
      76 |     if (entry.count > maxAttempts) {
    > 77 |       console.warn(`[RateLimit] Blocked request from ${key} (${entry.count} attempts)`);
         |               ^
      78 |       
      79 |       return res.status(429).json({
      80 |         message,

      at middleware/rateLimit.js:77:15
      at Object.<anonymous> (tests/middleware/rateLimit.test.js:146:7)

  console.warn                                                                                                                                      
    [RateLimit] Blocked request from 10.0.0.6 (2 attempts)                                                                                          

      75 |
      76 |     if (entry.count > maxAttempts) {
    > 77 |       console.warn(`[RateLimit] Blocked request from ${key} (${entry.count} attempts)`);
         |               ^
      78 |       
      79 |       return res.status(429).json({
      80 |         message,

      at middleware/rateLimit.js:77:15
      at Object.<anonymous> (tests/middleware/rateLimit.test.js:164:7)

  console.warn                                                                                                                                      
    [RateLimit] Blocked request from 10.0.0.10:login-test@example.com (6 attempts)                                                                  

      75 |
      76 |     if (entry.count > maxAttempts) {
    > 77 |       console.warn(`[RateLimit] Blocked request from ${key} (${entry.count} attempts)`);
         |               ^
      78 |       
      79 |       return res.status(429).json({
      80 |         message,

      at middleware/rateLimit.js:77:15
      at Object.<anonymous> (tests/middleware/rateLimit.test.js:193:7)

  console.warn
    [RateLimit] Blocked request from 10.0.0.11 (31 attempts)

      75 |
      76 |     if (entry.count > maxAttempts) {
    > 77 |       console.warn(`[RateLimit] Blocked request from ${key} (${entry.count} attempts)`);
         |               ^
      78 |       
      79 |       return res.status(429).json({
      80 |         message,

      at middleware/rateLimit.js:77:15
      at Object.<anonymous> (tests/middleware/rateLimit.test.js:216:7)

  console.warn                                                                                                                                      
    [RateLimit] Blocked request from 192.168.1.1 (3 attempts)                                                                                       

      75 |
      76 |     if (entry.count > maxAttempts) {
    > 77 |       console.warn(`[RateLimit] Blocked request from ${key} (${entry.count} attempts)`);
         |               ^
      78 |       
      79 |       return res.status(429).json({
      80 |         message,

      at middleware/rateLimit.js:77:15
      at Object.<anonymous> (tests/middleware/rateLimit.test.js:238:7)

  console.warn                                                                                                                                      
    [RateLimit] Blocked request from unknown (2 attempts)                                                                                           

      75 |
      76 |     if (entry.count > maxAttempts) {
    > 77 |       console.warn(`[RateLimit] Blocked request from ${key} (${entry.count} attempts)`);
         |               ^
      78 |       
      79 |       return res.status(429).json({
      80 |         message,

      at middleware/rateLimit.js:77:15
      at Object.<anonymous> (tests/middleware/rateLimit.test.js:255:7)

 PASS  tests/middleware/rateLimit.test.js
  Rate Limiting Middleware
    createRateLimiter
      √ should allow requests under the limit (2 ms)
      √ should block requests over the limit (6 ms)
      √ should set rate limit headers (2 ms)
      √ should track by IP + email when useEmail is true (1 ms)
      √ should normalize email to lowercase for tracking (3 ms)
      √ should include retryAfter in blocked response (4 ms)
    loginRateLimiter
      √ should have correct configuration for login attempts (4 ms)
    refreshRateLimiter
      √ should have higher limit than login (6 ms)
    IP Fallback
      √ should use connection.remoteAddress if ip is not available (5 ms)
      √ should use "unknown" if no IP source available (4 ms)

  console.log
    ✅ Connected to MariaDB (Promise Pool)

      at db.js:13:9

 FAIL  tests/integration/refreshToken.test.js
  Token Refresh Flow Integration Tests
    generateTokens
      √ should generate valid access and refresh tokens (9 ms)
      × should include role name from database if not provided (57 ms)
    loginUser
      × should return tokens and user on successful login
      × should throw error for non-existent user (16 ms)
      × should throw error for invalid password
    refreshAccessToken
      × should issue new token pair on valid refresh (11 ms)
      × should detect and reject reused refresh tokens (9 ms)
      × should reject tokens not found in database (10 ms)
      √ should reject expired refresh tokens (4 ms)
      √ should reject tokens signed with wrong secret (3 ms)
  ● Token Refresh Flow Integration Tests › generateTokens › should include role name from database if not provided
                                                                                                                                                    
    Access denied for user 'test'@'localhost' (using password: NO)

      27 |   let roleName = user.role_name; // Use if already provided
      28 |   if (!roleName && user.user_role_id) {
    > 29 |     const [roleRows] = await db.query(
         |                                 ^
      30 |       'SELECT role_name FROM user_role WHERE id = ?',
      31 |       [user.user_role_id]
      32 |     );

      at PromisePool.query (../node_modules/mysql2/lib/promise/pool.js:36:22)
      at Module.generateTokens (services/authService.js:29:33)
      at Object.<anonymous> (tests/integration/refreshToken.test.js:76:49)

  ● Token Refresh Flow Integration Tests › loginUser › should return tokens and user on successful login

    TypeError: bcrypt.compare.mockResolvedValue is not a function

      90 |       mockQuery.mockResolvedValueOnce([{ affectedRows: 1 }]);
      91 |       
    > 92 |       bcrypt.compare.mockResolvedValue(true);
         |                      ^
      93 |
      94 |       const result = await authService.loginUser(testUser.email, 'password123');
      95 |

      at Object.<anonymous> (tests/integration/refreshToken.test.js:92:22)

  ● Token Refresh Flow Integration Tests › loginUser › should throw error for non-existent user

    expect(received).rejects.toThrow(expected)

    Expected substring: "User not found"
    Received message:   "Access denied for user 'test'@'localhost' (using password: NO)"

          60 |   // 1. Verify credentials
          61 |   // Use Stored Procedure
        > 62 |   const [rows] = await db.query('CALL GetUserByEmail(?)', [email]);
             |                           ^
          63 |   const users = rows[0]; // SP returns [[user], ...]
          64 |
          65 |   if (!users || users.length === 0) {

          at PromisePool.query (../node_modules/mysql2/lib/promise/pool.js:36:22)
          at Module.loginUser (services/authService.js:62:27)
          at Object.<anonymous> (tests/integration/refreshToken.test.js:110:32)

      109 |
      110 |       await expect(authService.loginUser('nonexistent@example.com', 'password'))
    > 111 |         .rejects.toThrow('User not found');
          |                  ^
      112 |     });
      113 |
      114 |     test('should throw error for invalid password', async () => {

      at Object.toThrow (../node_modules/expect/build/index.js:218:22)
      at Object.<anonymous> (tests/integration/refreshToken.test.js:111:18)

  ● Token Refresh Flow Integration Tests › loginUser › should throw error for invalid password

    TypeError: bcrypt.compare.mockResolvedValue is not a function

      115 |       mockQuery.mockResolvedValueOnce([[[testUser]]]);
      116 |       mockQuery.mockResolvedValueOnce([[{ role_name: 'Tourist' }]]);
    > 117 |       bcrypt.compare.mockResolvedValue(false);
          |                      ^
      118 |
      119 |       await expect(authService.loginUser(testUser.email, 'wrongpassword'))
      120 |         .rejects.toThrow('Invalid credentials');

      at Object.<anonymous> (tests/integration/refreshToken.test.js:117:22)

  ● Token Refresh Flow Integration Tests › refreshAccessToken › should issue new token pair on valid refresh

    Access denied for user 'test'@'localhost' (using password: NO)

      115 |
      116 |   // Check DB
    > 117 |   const [rows] = await db.query('CALL GetRefreshToken(?)', [tokenHash]);
          |                           ^
      118 |   const tokens = rows[0];
      119 |
      120 |   if (!tokens || tokens.length === 0) {

      at PromisePool.query (../node_modules/mysql2/lib/promise/pool.js:36:22)
      at Module.refreshAccessToken (services/authService.js:117:27)
      at Object.<anonymous> (tests/integration/refreshToken.test.js:156:40)

  ● Token Refresh Flow Integration Tests › refreshAccessToken › should detect and reject reused refresh tokens

    expect(received).rejects.toThrow(expected)

    Expected substring: "Refresh token reuse detected - session invalidated"
    Received message:   "Access denied for user 'test'@'localhost' (using password: NO)"

          115 |
          116 |   // Check DB
        > 117 |   const [rows] = await db.query('CALL GetRefreshToken(?)', [tokenHash]);
              |                           ^
          118 |   const tokens = rows[0];
          119 |
          120 |   if (!tokens || tokens.length === 0) {

          at PromisePool.query (../node_modules/mysql2/lib/promise/pool.js:36:22)
          at Module.refreshAccessToken (services/authService.js:117:27)
          at Object.<anonymous> (tests/integration/refreshToken.test.js:190:32)

      189 |
      190 |       await expect(authService.refreshAccessToken(refreshToken))
    > 191 |         .rejects.toThrow('Refresh token reuse detected - session invalidated');
          |                  ^
      192 |
      193 |       // Verify family was revoked
      194 |       expect(mockQuery).toHaveBeenCalledWith(

      at Object.toThrow (../node_modules/expect/build/index.js:218:22)
      at Object.<anonymous> (tests/integration/refreshToken.test.js:191:18)

  ● Token Refresh Flow Integration Tests › refreshAccessToken › should reject tokens not found in database

    expect(received).rejects.toThrow(expected)

    Expected substring: "Invalid refresh token (not found)"
    Received message:   "Access denied for user 'test'@'localhost' (using password: NO)"

          115 |
          116 |   // Check DB
        > 117 |   const [rows] = await db.query('CALL GetRefreshToken(?)', [tokenHash]);
              |                           ^
          118 |   const tokens = rows[0];
          119 |
          120 |   if (!tokens || tokens.length === 0) {

          at PromisePool.query (../node_modules/mysql2/lib/promise/pool.js:36:22)
          at Module.refreshAccessToken (services/authService.js:117:27)
          at Object.<anonymous> (tests/integration/refreshToken.test.js:211:32)

      210 |
      211 |       await expect(authService.refreshAccessToken(refreshToken))
    > 212 |         .rejects.toThrow('Invalid refresh token (not found)');
          |                  ^
      213 |     });
      214 |
      215 |     test('should reject expired refresh tokens', async () => {

      at Object.toThrow (../node_modules/expect/build/index.js:218:22)
      at Object.<anonymous> (tests/integration/refreshToken.test.js:212:18)

  ● Token Refresh Flow Integration Tests › refreshAccessToken › should increment version on rotation

    Access denied for user 'test'@'localhost' (using password: NO)

      115 |
      116 |   // Check DB
    > 117 |   const [rows] = await db.query('CALL GetRefreshToken(?)', [tokenHash]);
          |                           ^
      224 |     const tokenHash = hashToken(incomingRefreshToken);
    > 225 |     await db.query('CALL DeleteRefreshToken(?)', [tokenHash]);
          |              ^
      226 | }
      227 |
      228 |

      at PromisePool.query (../node_modules/mysql2/lib/promise/pool.js:36:22)
      at Module.logout (services/authService.js:225:14)
      at Object.<anonymous> (tests/integration/refreshToken.test.js:282:25)

  ● Token Refresh Flow Integration Tests › revokeUserRefreshTokens › should revoke all tokens for a user

    Access denied for user 'test'@'localhost' (using password: NO)

      217 |
      218 | export async function revokeUserRefreshTokens(userId) {
    > 219 |   await db.query('CALL RevokeUserRefreshTokens(?)', [userId]);
          |            ^
      220 | }
      221 |
      222 | export async function logout(incomingRefreshToken) {

      at PromisePool.query (../node_modules/mysql2/lib/promise/pool.js:36:22)
      at Module.revokeUserRefreshTokens (services/authService.js:219:12)
      at Object.<anonymous> (tests/integration/refreshToken.test.js:300:25)

  ● Token Refresh Concurrent Request Handling › should handle race condition on concurrent refresh attempts

    Access denied for user 'test'@'localhost' (using password: NO)

      115 |
      116 |   // Check DB
    > 117 |   const [rows] = await db.query('CALL GetRefreshToken(?)', [tokenHash]);
          |                           ^
      118 |   const tokens = rows[0];
      119 |
      120 |   if (!tokens || tokens.length === 0) {

      at PromisePool.query (../node_modules/mysql2/lib/promise/pool.js:36:22)
      at Module.refreshAccessToken (services/authService.js:117:27)
      at Object.<anonymous> (tests/integration/refreshToken.test.js:351:43)

Test Suites: 1 failed, 2 passed, 3 total
Tests:       11 failed, 27 passed, 38 total
Snapshots:   0 total
Time:        1.413 s
Ran all test suites.
Jest did not exit one second after the test run has completed.

'This usually means that there are asynchronous operations that weren't stopped in your tests. Consider running Jest with `--detectOpenHandles` to troubleshoot this issue.